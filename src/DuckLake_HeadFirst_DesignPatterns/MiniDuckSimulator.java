package DuckLake_HeadFirst_DesignPatterns;

import DuckLake_HeadFirst_DesignPatterns.Behavior.Duck;
import DuckLake_HeadFirst_DesignPatterns.Behavior.Fly.FlyRocketPowered;
import DuckLake_HeadFirst_DesignPatterns.Ducks.DecoyDuck;
import DuckLake_HeadFirst_DesignPatterns.Ducks.MallardDuck;
import DuckLake_HeadFirst_DesignPatterns.Ducks.ModelDuck;
import DuckLake_HeadFirst_DesignPatterns.Ducks.RubberDuck;

public class MiniDuckSimulator {
    public static void main(String[] args) {

        /*
        * Паттерн Стратегия
        *
        * 1. разделить изменяемое и неизменяемое (инкапсулировать изменяемое)
        * 2. композиция > наследование (т.к. композиция позволяет работать гораздо более гибко, чем наследование)
        * 3. программируйте на уровне интерфейсов, а не реализации (хотя в данном примере как раз-таки
        * сделано обратное, забавно. Еще не совсем понимаю, как это правило конкретно должно работать)
        *
        * Цель паттерна Стратегия заключен в том, чтобы создавать ЭФФЕКТИВНЫЕ и гибкие системы, методы которых может
        * использовать любой класс, ограничиваясь только модификаторами доступа, а не наследованием
        *
        * В данном примере можно было бы использовать наследование - просто расположить метод Fly и Quack внутри
        * класса Duck, однако это вызывало проблемы, поскольку пришлось бы вручную переопределять поведение резиновой
        * уточки и деревянной утки-приманки, иначе они начинали летать и крякать, как обычные утки.
        * Переопределять вручную неудобно и непрактично - кроме резиновой и деревянной, могла появиться
        * и моделька утки, и стеклянная статуэтка утки и много чего еще. Переопределять каждый раз вручную?
        * Сопровождение скинется на киллера и ваши похороны за такой "подарок".
        *
        * Летать может не только утка, но и сова, и самолет, и ракета. Если бы понадобилось ввести в игру еще и сов
        * с летучими мышами (например, как ивент на Хэллоуин) пришлось бы заново писать для них метод Fly, а для
        * каких-нибудь журавлей или гусей - метод Quack.
        *
        * Неудобно, непрактично, куча повторений кода (кто-нибудь, откачайте фаната "Чистого кода", мне кажется,
        * у него приступ "ЭТО ЖЕ НЕЭФФЕКТИВНО", это было слишком жестоко)
        *
        * Информация об утках - неизменяемая, однако информация о том, КАК они действуют - изменяемая.
        * Следовательно, нужно инкапсулировать методы Fly и Quack (аналогично можно инкапсулировать и метод swim())
        *
        * Можно сделать это просто через интерфейсы Flyable и Quackable - только те классы, которым это необходимо,
        * реализуют данные интерфейсы. Однако это все равно плохое решение - во-первых, невозможно изменить то, что
        * делает утка, "на ходу", во время исполнения программы - это не гибко.
        * А вдруг выпустят новую утку-приманку, способную крякать?
        * Во-вторых, решение с интерфейсом все равно громоздкое и вызывает много повторений в коде - да, с помощью
        * модификатора default возможно написать развернутый метод в интерфейсе, который смогут использовать все классы,
        * реализующие данный интерфейс (что, кстати, не предлагается в учебнике, интересно, почему?), однако!
        * Птицы могут летать по-разному - они могут совершать длинные перелеты, взлетать, пикировать, парить,
        * лететь кругами или на бреющем полете. Каждый раз обращаться к различным методам (т.е. при каждом вызове метода
        * мы должны вручную обращаться к конкретному, чтобы полет был правильным, нельзя просто сделать fly() - о какой
        * унификации и компактности кода идет речь? Ее тут не существует)
        * В крайнем случае даже переопределять каждый метод под конкретную птицу?
        *
        * (фанату "Чистого кода" снова плохо, врача врача, позовите врача)
        *
        * Следовательно, нужно инкапсулировать fly() и quack() так, чтобы
        * 1. методы мог использовать любой класс
        * 2. были разные варианты поведения (например, полет с помощью крыльев и полет с помощью реактивной тяги)
        * 3. чтобы поведение могло изменяться во время исполнения программы,
        * без вмешательства клиента в код (это просто неприемлемо)
        * 4. чтобы один и тот же метод (fly()) мог контролируемо вызывать разное поведение (полет с крыльями или
        * на реактивной тяге)
        *
        * Решение состоит в том, чтобы реализовать поведение при помощи иерархии, состоящей из:
        * интерфейса FlyBehavior, реализующего метод fly()
        * классов FlyNoWay, FlyWithWings, FlyRocketPowered, реализующих интерфейс FlyBehavior, и, соответственно,
        * имеющих внутри КОНКРЕТНУЮ реализацию метода fly()
        *
        * Дальше необходимо создать внутри суперкласса Duck переменную, которая будет отвечать за то, какой тип поведения
        * реализует объект:
        * FlyBehavior flyBehavior;
        *
        * Далее нужно добавить:
        * public void performFly() {flyBehavior.fly();}
        * Этот метод будет заставлять утку летать, и, в зависимости от переменной flyBehavior,
        * определять поведение полета
        *
        * Последний этап - добавить самый обычный сеттер для flyBehavior, чтобы мы могли изменять поведение, не меняя
        * используемый метод:
        *
        * public void setFlyBehavior(FlyBehavior fb) {flyBehavior = fb;}
        *
        * Вы великолепны, а утки могут летать!
        *
        * Теперь нужно повторить все то же самое для QuackBehavior.
        * */


        //здесь просто скучная инициализация объектов и проверка методов
        //создаем утку
        Duck mallardDuck = new MallardDuck();
        //вытаскиваем ее на свет божий
        mallardDuck.display();
        //заставляем крякнуть
        mallardDuck.performQuack();
        //и полететь
        mallardDuck.performFly();

        Duck rubberDuck = new RubberDuck();
        rubberDuck.display();
        rubberDuck.performQuack();
        rubberDuck.performFly();

        Duck decoyDuck = new DecoyDuck();
        decoyDuck.display();
        decoyDuck.performQuack();
        decoyDuck.performFly();

        Duck modelDuck = new ModelDuck();
        modelDuck.display();
        //что-то новое, заставляем животное плавать
        modelDuck.swim();
        modelDuck.performFly();
        modelDuck.performQuack();
        //наконец-то меняем поведение - теперь вместо нормальной... неспособности летать,
        // мы привязали к утке (к модельке, МОДЕЛЬКЕ, гринпис, не бей) ракетный ускоритель
        modelDuck.setFlyBehavior(new FlyRocketPowered());
        //Белка и Стрелка покорили космос, а чем утка хуже?
        modelDuck.performFly();

        /*
        * Итак, почему утки могут/не могут летать сразу, несмотря на то, что мы еще не задействовали сеттер?
        * Потому что внутри каждого класса конкретной утки есть такая штука:
        *
        * public ModelDuck() {
            flyBehavior = new FlyNoWay();
            quackBehavior = new Quack();
         }
         *
         * Простигосподи, опять забыла, как это называется, суть в том, что название этого метода повторяет название
         * класса, и при создании объектов без аргумента переменные назначаются автоматически*/

    }
}
